

// client/src/pages/Reviews.jsx
import{AccountCircle,AccessTime,Search,Clear,Edit,ThumbUp,ThumbDown,Chat}from'@mui/icons-material';import React,{useContext,useEffect,useState,useRef}from'react';import UserContext from'../contexts/UserContext';import{Link}from'react-router-dom';import{Box,Typography,Grid,Card,CardContent,Input,IconButton,Button,Avatar,Divider,Select,MenuItem,FormControl,InputLabel}from'@mui/material';import dayjs from'dayjs';import global from'../global';import http from'../http';import StarRating from'../components/StarRating';const SEARCH_OPTIONS=[{value:'title',label:'Title only'},{value:'content',label:'Contents only'},{value:'all',label:'Title and Contents'},];function Reviews(){const [reviewList,setReviewList]=useState([]);const [search,setSearch]=useState('');const [searchScope,setSearchScope]=useState('all');const{user}=useContext(UserContext);const debounceTimeout=useRef();const getReviews=()=>{http.get('/reviews').then((res)=>{setReviewList(res.data.filter(r=>!r.deleted));});};const searchReviews=()=>{const params=new URLSearchParams();if(search)params.append('search',search);if(searchScope)params.append('scope',searchScope);http.get(`/reviews?${params.toString()}`).then((res)=>setReviewList(res.data));};const toggleLike=(id)=>{http.post(`/reviews/${id}/vote`,{upvote:true}).then(res=>{setReviewList(prev=>prev.map(r=>r.id===id?{...r,liked:!r.liked,disliked:false,upvotes:res.data.upvotes,downvotes:res.data.downvotes}:r));}).catch(err=>console.error("Failed to toggle like vote:",err));};const toggleDislike=(id)=>{http.post(`/reviews/${id}/vote`,{upvote:false}).then(res=>{setReviewList(prev=>prev.map(r=>r.id===id?{...r,liked:false,disliked:!r.disliked,upvotes:res.data.upvotes,downvotes:res.data.downvotes}:r));}).catch(err=>console.error("Failed to toggle dislike vote:",err));};useEffect(()=>{getReviews();},[]);useEffect(()=>{if(debounceTimeout.current)clearTimeout(debounceTimeout.current);if(search){debounceTimeout.current=setTimeout(()=>{searchReviews();},400);}else{getReviews();}return()=>clearTimeout(debounceTimeout.current);},[search,searchScope]);const onSearchChange=(e)=>setSearch(e.target.value);const onScopeChange=(e)=>setSearchScope(e.target.value);const onClickClear=()=>{setSearch('');getReviews();};return(<Box><Typography variant="h5"sx={{my:2,fontWeight:'bold'}}>Reviews</Typography><Box sx={{display:'flex',alignItems:'center',mb:2}}><Input
value={search}placeholder="Search"onChange={onSearchChange}sx={{flex:1,mr:1}}/><FormControl size="small"sx={{minWidth:150,mr:1}}><InputLabel id="search-scope-label">Search in</InputLabel><Select
labelId="search-scope-label"value={searchScope}label="Search in"onChange={onScopeChange}>{SEARCH_OPTIONS.map(opt=>(<MenuItem key={opt.value}value={opt.value}>{opt.label}</MenuItem>))}</Select></FormControl><IconButton color="primary"onClick={searchReviews}><Search/></IconButton><IconButton color="primary"onClick={onClickClear}><Clear/></IconButton><Box sx={{flexGrow:1}}/>{user&&(<Link to="/addreview"style={{textDecoration:'none'}}><Button variant='contained'>Add Review</Button></Link>)}</Box><Grid container spacing={3}>{reviewList.map((review)=>(<Grid item xs={12}md={6}lg={4}key={review.id}><Card sx={{boxShadow:3,borderRadius:3}}><CardContent><Box sx={{display:'flex',alignItems:'center',mb:1}}><Avatar sx={{bgcolor:'primary.main',mr:1}}>{review.reviewer?.name?.[0]||<AccountCircle/>}</Avatar><Box sx={{flex:1}}><Typography variant="subtitle1"fontWeight="bold"sx={{mb:-0.5,mt:-1}}>{review.reviewer?.name}</Typography><Typography variant="caption"color="text.secondary"><AccessTime sx={{verticalAlign:'middle',mr:0.5}}fontSize="small"/>{dayjs(review.createdAt||review.postDateTime).format(global.datetimeFormat)}</Typography></Box>{user&&user.id===review.reviewerId&&(<Link to={`/editreview/${review.id}`}><IconButton color="primary"sx={{p:'4px'}}><Edit/></IconButton></Link>)}</Box><Divider sx={{mb:1}}/><Link
to={`/reviews/${review.id}`}style={{textDecoration:'none',color:'inherit'}}><Typography variant="h6"sx={{mb:1}}>{review.title}</Typography><StarRating value={review.stars}readOnly size="small"/><Typography sx={{mt:1,mb:1}}>{review.description}</Typography></Link><Box sx={{display:'flex',alignItems:'center',gap:1,mb:-1}}><Box sx={{gap:0}}><IconButton
color={user&&review.liked?'success':'default'}onClick={()=>toggleLike(review.id)}><ThumbUp fontSize="small"/></IconButton><Typography variant="caption">{review.upvotes??0}</Typography></Box><Box sx={{gap:0}}><IconButton
color={user&&review.disliked?'error':'default'}onClick={()=>toggleDislike(review.id)}><ThumbDown fontSize="small"/></IconButton><Typography variant="caption">{review.downvotes??0}</Typography></Box><Box sx={{flexGrow:1}}/><Box sx={{gap:0}}><IconButton disabled><Chat fontSize="small"/></IconButton><Typography variant="caption">{review.replyCount||0}</Typography></Box></Box></CardContent></Card></Grid>))}</Grid></Box>);}export default Reviews;

// client/src/App.jsx
import'./App.css';import Reviews from'./pages/Reviews';import Review from'./pages/Review';import AddReview from'./pages/AddReview';import EditReview from'./pages/EditReview';import Register from'./pages/Register';import Login from'./pages/Login';import UserContext from'./contexts/UserContext';import{Container,AppBar,Box,Button,Toolbar,Typography}from'@mui/material';import{BrowserRouter as Router,Routes,Route,Link,useLocation}from'react-router-dom';import{useState,useEffect}from'react';import{ThemeProvider}from'@mui/material/styles';import MyTheme from'./themes/MyTheme';import http from'./http';import Home from'./pages/Home';function AppBarLinks({user,logout}){const location=useLocation();const currentPath=location.pathname;return(<>{user&&(<><Typography>{user.name}</Typography><Button onClick={logout}>Logout</Button></>)}{!user&&(<><Link to={`/register?from=${encodeURIComponent(currentPath)}`}><Typography>Register</Typography></Link><Link to={`/login?from=${encodeURIComponent(currentPath)}`}><Typography>Login</Typography></Link></>)}</>)}function App(){const [user,setUser]=useState(null);useEffect(()=>{if(localStorage.getItem("accessToken")){http.get('/user/auth').then((res)=>{setUser(res.data.user);});}},[]);const logout=()=>{if(window.confirm("Are you sure you want to logout?")){if(window.confirm("Please confirm again to logout.")){localStorage.clear();window.location="/";}}};return(<UserContext.Provider value={{user,setUser}}><Router><ThemeProvider theme={MyTheme}><AppBar position="static"className='AppBar'><Container><Toolbar disableGutters={true}><Link to="/"><Typography variant="h6"component="div">Descode</Typography></Link><Link to="/reviews"><Typography>Reviews</Typography></Link><Box sx={{flexGrow:1}}></Box><AppBarLinks user={user}logout={logout}/></Toolbar></Container></AppBar><Container><Routes><Route path={"/"}element={<Home/>}/><Route path={"/reviews"}element={<Reviews/>}/><Route path={"/reviews/:id"}element={<Review/>}/><Route path={"/addreview"}element={<AddReview/>}/><Route path={"/editreview/:id"}element={<EditReview/>}/><Route path={"/register"}element={<Register/>}/><Route path={"/login"}element={<Login/>}/></Routes></Container></ThemeProvider></Router></UserContext.Provider>);}export default App;

// server/models/Admin.js
module.exports=(sequelize,DataTypes)=>{const Admin=sequelize.define("Admin",{id:{type:DataTypes.INTEGER,primaryKey:true,autoIncrement:true},name:{type:DataTypes.STRING(50),allowNull:false,unique:true},password:{type:DataTypes.STRING(100),allowNull:false},email:{type:DataTypes.STRING(50),allowNull:false,unique:true},createdAt:{type:DataTypes.DATE,allowNull:false},updatedAt:{type:DataTypes.DATE,allowNull:false}},{tableName:'admins',timestamps:true});return Admin;};

// server/models/Review.js
module.exports=(sequelize,DataTypes)=>{const Review=sequelize.define("Review",{id:{type:DataTypes.INTEGER,primaryKey:true,autoIncrement:true},stars:{type:DataTypes.INTEGER,allowNull:false,validate:{min:1,max:5}},title:{type:DataTypes.STRING(100),allowNull:false},description:{type:DataTypes.TEXT,allowNull:false},upvotes:{type:DataTypes.INTEGER,allowNull:true,defaultValue:0},downvotes:{type:DataTypes.INTEGER,allowNull:true,defaultValue:0},postDateTime:{type:DataTypes.DATE,allowNull:false,defaultValue:DataTypes.NOW},editDateTime:{type:DataTypes.DATE,allowNull:true},deleted:{type:DataTypes.BOOLEAN,allowNull:false,defaultValue:false},reviewerId:{type:DataTypes.INTEGER,allowNull:false,references:{model:'users',key:'id'}}},{tableName:'reviews',timestamps:false});Review.associate=(models)=>{Review.belongsTo(models.User,{foreignKey:'reviewerId',as:'reviewer'});Review.hasMany(models.ReviewReply,{foreignKey:'ReviewID',as:'replies'});Review.hasMany(models.ReviewVote,{foreignKey:'ReviewID',as:'reviewVotes'});};return Review;};

// server/models/ReviewReply.js
module.exports=(sequelize,DataTypes)=>{const ReviewReply=sequelize.define("ReviewReply",{ReplyID:{type:DataTypes.INTEGER,primaryKey:true,autoIncrement:true},Content:{type:DataTypes.TEXT,allowNull:false},upvotes:{type:DataTypes.INTEGER,allowNull:true,defaultValue:0},downvotes:{type:DataTypes.INTEGER,allowNull:true,defaultValue:0},PostDateTime:{type:DataTypes.DATE,allowNull:false,defaultValue:DataTypes.NOW},EditDateTime:{type:DataTypes.DATE,allowNull:true},ReviewID:{type:DataTypes.INTEGER,allowNull:false},ReplierID:{type:DataTypes.INTEGER,allowNull:false}},{tableName:'review_replies',timestamps:false});ReviewReply.associate=(models)=>{ReviewReply.belongsTo(models.Review,{foreignKey:'ReviewID',as:'review'});ReviewReply.belongsTo(models.Admin,{foreignKey:'ReplierID',as:'Replier'});ReviewReply.hasMany(models.ReplyVote,{foreignKey:'ReplyID',as:'replyVotes'});};return ReviewReply;};

// server/models/User.js
module.exports=(sequelize,DataTypes)=>{const User=sequelize.define("User",{id:{type:DataTypes.INTEGER,primaryKey:true,autoIncrement:true},name:{type:DataTypes.STRING(50),allowNull:false},email:{type:DataTypes.STRING(50),allowNull:false},password:{type:DataTypes.STRING(100),allowNull:false},createdAt:{type:DataTypes.DATE,allowNull:false,defaultValue:DataTypes.NOW},updatedAt:{type:DataTypes.DATE,allowNull:false,defaultValue:DataTypes.NOW}},{tableName:'users',timestamps:true});User.associate=(models)=>{User.hasMany(models.Review,{foreignKey:'reviewerId',as:'Reviews'});User.hasMany(models.ReviewVote,{foreignKey:'UserID',as:'ReviewVotes'});User.hasMany(models.ReplyVote,{foreignKey:'UserID',as:'ReplyVotes'});};return User;};

// server/models/ReviewVote.js
module.exports=(sequelize,DataTypes)=>{const ReviewVote=sequelize.define("ReviewVote",{UserID:{type:DataTypes.INTEGER,primaryKey:true},ReviewID:{type:DataTypes.INTEGER,primaryKey:true},Upvote:{type:DataTypes.BOOLEAN,allowNull:false}},{tableName:'review_votes',timestamps:false});ReviewVote.associate=(models)=>{ReviewVote.belongsTo(models.User,{foreignKey:'UserID'});ReviewVote.belongsTo(models.Review,{foreignKey:'ReviewID'});};return ReviewVote;};

// server/models/ReplyVote.js
module.exports=(sequelize,DataTypes)=>{const ReplyVote=sequelize.define("ReplyVote",{UserID:{type:DataTypes.INTEGER,primaryKey:true},ReplyID:{type:DataTypes.INTEGER,primaryKey:true},Upvote:{type:DataTypes.BOOLEAN,allowNull:false}},{tableName:'reply_votes',timestamps:false});ReplyVote.associate=(models)=>{ReplyVote.belongsTo(models.User,{foreignKey:'UserID'});ReplyVote.belongsTo(models.ReviewReply,{foreignKey:'ReplyID'});};return ReplyVote;};

// server/routes/reviews.js
const express=require('express');const router=express.Router();const{User,Review,ReviewReply,Admin,ReviewVote}=require('../models');const{wiz}=require('../utils');const{Op,fn,col}=require("sequelize");const{validateToken}=require('../middlewares/auth');const yup=require("yup");let recentSubmissions={};const SPAM_LIMIT=3;function isSpam(userId,content){const now=Date.now();console.log(recentSubmissions);if(!recentSubmissions[userId]){recentSubmissions[userId]=[];}recentSubmissions[userId]=recentSubmissions[userId].filter(sub=>now - sub.time<5 * 60 * 1000);const similarCount=recentSubmissions[userId].filter(sub=>sub.content.includes(content.title)||sub.content.includes(content.description)).length;if(similarCount>=SPAM_LIMIT)return true;recentSubmissions[userId].push({content:`${content.title}${content.description}`,time:now});return false;}router.post("/",validateToken,async(req,res)=>{let data=req.body;data.reviewerId=req.user.id;if(isSpam(req.user.id,data)){return res.status(400).json({error:"Spam detected. Too many similar submissions."});}const validationSchema=yup.object({title:yup.string().trim().min(3).max(100).required(),description:yup.string().trim().min(3).max(500).required(),stars:yup.number().min(1).max(5).required()});try{data=await validationSchema.validate(data,{abortEarly:false});data.reviewerId=req.user.id;const result=await Review.create(data);const reviewWithUser=await Review.findByPk(result.id,{include:{model:User,as:'reviewer',attributes:['name']}});res.json(reviewWithUser);}catch(err){wiz(err,`Error while creating review:`)res.status(400).json({errors:err.errors});}});router.get('/',async(req,res)=>{let userId=null;const authHeader=req.headers.authorization;if(authHeader&&authHeader.startsWith("Bearer")){try{const token=authHeader.split("")[1];const decoded=require('jsonwebtoken').verify(token,process.env.APP_SECRET);userId=decoded.id;}catch(err){userId=null;}}try{const{search,scope}=req.query;let where={};if(search){if(scope==='title'){where.title={[Op.like]:`%${search}%`};}else if(scope==='content'){where.description={[Op.like]:`%${search}%`};}else{where[Op.or]=[{title:{[Op.like]:`%${search}%`}},{description:{[Op.like]:`%${search}%`}}];}}const reviewsRaw=await Review.findAll({where:{...where,deleted:false},include:[{model:User,as:'reviewer',attributes:['id','name']},{model:ReviewReply,as:'replies',attributes:[]},{model:ReviewVote,as:'reviewVotes',where:userId?{UserID:userId}:undefined,required:false,attributes:['Upvote']}],attributes:{include:[[fn('COUNT',col('replies.ReplyID')),'replyCount']]},group:['Review.id','reviewer.id','reviewVotes.ReviewID','reviewVotes.UserID'],order:[['postDateTime','DESC']]});const reviews=reviewsRaw.map(r=>{const vote=r.reviewVotes?.[0];return{...r.get({plain:true}),liked:vote?.Upvote===true,disliked:vote?.Upvote===false};});res.json(reviews);}catch(err){wiz(err,"Error while fetching reviews with reply counts:");res.status(500).json({error:"Failed to fetch reviews."});}});router.get("/:id",async(req,res)=>{const id=req.params.id;let userId=null;const authHeader=req.headers.authorization;if(authHeader&&authHeader.startsWith("Bearer")){try{const token=authHeader.split("")[1];const decoded=require('jsonwebtoken').verify(token,process.env.APP_SECRET);userId=decoded.id;}catch(err){userId=null;}}try{const reviewObj=await Review.findByPk(id,{include:[{model:User,as:'reviewer',attributes:['id','name']},{model:ReviewVote,as:'reviewVotes',where:userId?{UserID:userId}:undefined,required:false,attributes:['Upvote']}]});if(!reviewObj||reviewObj.deleted)return res.sendStatus(404);const plainReview=reviewObj.get({plain:true});const vote=plainReview.reviewVotes?.[0];const response={...plainReview,liked:vote?.Upvote===true,disliked:vote?.Upvote===false};res.json(response);}catch(err){wiz(err,`Error fetching review #${id}`);res.status(500).json({error:"Failed to fetch review."});}});router.get('/:id/replies',async(req,res)=>{try{const replies=await ReviewReply.findAll({where:{ReviewID:req.params.id},include:[{model:Admin,as:'Replier',attributes:['name','email']}],order:[['PostDateTime','ASC']]});res.json(replies);}catch(err){wiz(err,'Error fetching replies:');res.status(500).json({error:'Failed to fetch replies'});}});router.put("/:id",validateToken,async(req,res)=>{let id=req.params.id;let userId=req.user.id;try{const review=await Review.findByPk(id);if(!review||review.deleted){res.sendStatus(404);return;}if(review.reviewerId !==userId){res.sendStatus(403);return;}if(req.body.deleted===true){const num=await Review.update({deleted:true,editDateTime:new Date()},{where:{id}});if(num[0]===1){res.json({message:"Review was deleted(soft)successfully."});}else{res.status(400).json({message:`Cannot delete review with id ${id}.`});}return;}const{title,description,stars}=req.body;const num=await Review.update({title,description,stars,editDateTime:new Date()},{where:{id}});if(num[0]===1){res.json({message:"Review was updated successfully."});}else{res.status(400).json({message:`Cannot update review with id ${id}.`});}}catch(err){wiz(err,`Error while updating review #${id}:`)res.status(500).json({error:"Failed to update review."});}});router.delete("/:id",validateToken,async(req,res)=>{let id=req.params.id;let userId=req.user.id;try{const review=await Review.findByPk(id);if(!review||review.deleted){res.sendStatus(404);return;}if(review.reviewerId !==userId){res.sendStatus(403);return;}review.deleted=true;await review.save();const num=await Review.update({deleted:true},{where:{id}});if(num[0]===1){res.json({message:"Review was deleted successfully."});}else{res.status(400).json({message:`Cannot delete review with id ${id}.`});}}catch(err){wiz(err,`Error while deleting review #${id}:`)res.status(500).json({error:"Failed to delete review."});}});router.post('/:id/vote',validateToken,async(req,res)=>{const reviewId=parseInt(req.params.id);const userId=req.user.id;const{upvote}=req.body;if(typeof upvote !=='boolean'){return res.status(400).json({error:"Invalid vote value. Must be boolean."});}try{const existingVote=await ReviewVote.findOne({where:{ReviewID:reviewId,UserID:userId}});if(existingVote){if(existingVote.Upvote===upvote){await existingVote.destroy();}else{existingVote.Upvote=upvote;await existingVote.save();}}else{await ReviewVote.create({ReviewID:reviewId,UserID:userId,Upvote:upvote});}const upvotes=await ReviewVote.count({where:{ReviewID:reviewId,Upvote:true}});const downvotes=await ReviewVote.count({where:{ReviewID:reviewId,Upvote:false}});await Review.update({upvotes,downvotes},{where:{id:reviewId}});res.json({message:"Vote updated",upvotes,downvotes});}catch(err){wiz(err,"Error processing vote:");res.status(500).json({error:"Failed to process vote."});}});module.exports=router;

// server/routes/user.js
const express=require('express');const router=express.Router();const bcrypt=require('bcrypt');const{User}=require('../models');const{wiz}=require('../utils');const yup=require("yup");const{sign}=require('jsonwebtoken');const{validateToken}=require('../middlewares/auth');require('dotenv').config();const mapYupErrors=(err)=>err.errors?err.errors.join(''):'Validation failed.';router.post("/register",async(req,res)=>{let data=req.body;let validationSchema=yup.object({name:yup.string().trim().min(3).max(50).required().matches(/^[a-zA-Z'-,.]+$/,"Name only allow letters,spaces and characters:'- ,."),email:yup.string().trim().lowercase().email().max(50).required(),password:yup.string().trim().min(8).max(50).required().matches(/^(?=.*[a-zA-Z])(?=.*[0-9]).{8}$/,"Password at least 1 letter and 1 number")});try{data=await validationSchema.validate(data,{abortEarly:false});let user=await User.findOne({where:{email:data.email}});if(user){return res.status(400).json({message:"Email already exists."});}data.password=await bcrypt.hash(data.password,10);let result=await User.create(data);let userInfo={id:result.id,email:result.email,name:result.name};let accessToken=sign(userInfo,process.env.APP_SECRET,{expiresIn:process.env.TOKEN_EXPIRES_IN});res.json({accessToken,user:userInfo,message:'Registration successful!'});}catch(err){wiz(err,"Error while registering:\n")return res.status(400).json({message:mapYupErrors(err)});}});router.post("/login",async(req,res)=>{let data=req.body;let validationSchema=yup.object({email:yup.string().trim().lowercase().email().max(50).required(),password:yup.string().trim().min(8).max(50).required().matches(/^(?=.*[a-zA-Z])(?=.*[0-9]).{8}$/,"Password must have at least 1 letter and 1 number")});try{data=await validationSchema.validate(data,{abortEarly:false});let user=await User.findOne({where:{email:data.email}});if(!user){return res.status(400).json({message:"Email or password is not correct."});}let match=await bcrypt.compare(data.password,user.password);if(!match){return res.status(400).json({message:"Email or password is not correct."});}let userInfo={id:user.id,email:user.email,name:user.name};let accessToken=sign(userInfo,process.env.APP_SECRET,{expiresIn:process.env.TOKEN_EXPIRES_IN});res.json({accessToken:accessToken,user:userInfo});}catch(err){wiz(err,"Error while logging in:\n")res.status(400).json({errors:err.errors});}});module.exports=router;router.get("/",(req,res)=>{res.send("Can GET /user/");});router.get("/auth",validateToken,(req,res)=>{let userInfo={id:req.user.id,email:req.user.email,name:req.user.name};res.json({user:userInfo});});

// server/rests/reviewVote.test.js
const request=require('supertest');const jwt=require('jsonwebtoken');const app=require('../index');const{ReviewVote,Review,User,sequelize}=require('../models');const testUser={id:1,email:'testuser@example.com',name:'Test User'};const testReviewId=1;const appSecret=process.env.APP_SECRET||'testsecret';describe('POST /reviews/:id/vote',()=>{let token;beforeAll(async()=>{token=jwt.sign(testUser,appSecret,{expiresIn:'1h'});});afterAll(async()=>{await sequelize.close();});test('should reject without auth token',async()=>{const res=await request(app).post(`/reviews/${testReviewId}/vote`).send({upvote:true});expect(res.statusCode).toBe(401);});test('should reject when upvote is missing or invalid type',async()=>{const res=await request(app).post(`/reviews/${testReviewId}/vote`).set('Authorization',`Bearer ${token}`).send({upvote:'not_boolean'});expect(res.statusCode).toBe(400);expect(res.body.error).toBe('Invalid vote value. Must be boolean.');});test('should create upvote if none exists',async()=>{const res=await request(app).post(`/reviews/${testReviewId}/vote`).set('Authorization',`Bearer ${token}`).send({upvote:true});expect(res.statusCode).toBe(200);expect(res.body).toHaveProperty('message','Vote updated');expect(res.body).toHaveProperty('upvotes');expect(res.body).toHaveProperty('downvotes');});test('should toggle(remove)existing upvote on repeated vote',async()=>{let res=await request(app).post(`/reviews/${testReviewId}/vote`).set('Authorization',`Bearer ${token}`).send({upvote:true});expect(res.statusCode).toBe(200);res=await request(app).post(`/reviews/${testReviewId}/vote`).set('Authorization',`Bearer ${token}`).send({upvote:true});expect(res.statusCode).toBe(200);});test('should change vote from upvote to downvote',async()=>{await request(app).post(`/reviews/${testReviewId}/vote`).set('Authorization',`Bearer ${token}`).send({upvote:true});const res=await request(app).post(`/reviews/${testReviewId}/vote`).set('Authorization',`Bearer ${token}`).send({upvote:false});expect(res.statusCode).toBe(200);expect(res.body).toHaveProperty('message','Vote updated');});test('should handle non-existent review id gracefully',async()=>{const nonExistentId=999999;const res=await request(app).post(`/reviews/${nonExistentId}/vote`).set('Authorization',`Bearer ${token}`).send({upvote:true});expect([200,500]).toContain(res.statusCode);});});

// server/index.js
require('dotenv').config();const express=require('express');const cors=require('cors');const app=express();app.use(express.json());app.use(cors({origin:process.env.CLIENT_URL}));app.get("/",(req,res)=>{res.send("Welcome to the learning space.");});const reviewRoute=require('./routes/reviews');app.use("/reviews",reviewRoute);const userRoute=require('./routes/user');app.use("/user",userRoute);const fileRoute=require('./routes/file');app.use("/file",fileRoute)const db=require('./models');if(require.main===module){db.sequelize.sync().then(()=>{let port=process.env.APP_PORT;app.listen(port,()=>{console.log(`┌╮┌╴╭╮╭╮╭╮┌╮┌╴  ╭╮┌╴┌╮╷╷┌╴┌╮
││├ ╰╮│ ││││├   ╰╮├ │ ││├ │
└╯└╴╰╯╰╯╰╯└╯└╴  ╰╯└╴╵ └╯└╴╵
Server running on http:});}).catch((err)=>{console.log(err);});}module.exports=app;

{"name":"server","version":"1.0.0","main":"index.js","scripts":{"start":"nodemon index.js","test":"jest","omaewamoushindeiru":"taskkill /F /IM node.exe"},"keywords":[],"author":"","license":"ISC","description":"","dependencies":{"bcrypt":"^6.0.0","cors":"^2.8.5","dotenv":"^17.0.0","express":"^5.1.0","jsonwebtoken":"^9.0.2","multer":"^2.0.2","mysql2":"^3.14.1","sequelize":"^6.37.7","yup":"^1.6.1"},"devDependencies":{"jest":"^30.0.5","nodemon":"^3.1.10","supertest":"^7.1.4"}}